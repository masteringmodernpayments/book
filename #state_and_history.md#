[aasm]: https://github.com/aasm/aasm
[fmsc]: http://weblog.jamisbuck.org/2006/10/18/skinny-controller-fat-model
[paper_trail]: https://github.com/airblade/paper_trail

# State and History

So far in our little example app we can buy and sell downloadable products using Stripe. We're not keeping much information in our own database, though. We can't easily see how much we've earned, we can't see how big Stripe's cut has been. Ideally our application's database would keep track of this. The mantra with financial transactions should always be "trust and verify". To that end we should be tracking sales through each stage of the process, from the point the customer clicks the buy button all the way through to the po

## State Machines

Ideally, we'd like to be able to trace each sale through from initialization to completion, including purchase, refunds, errors, etc. One step along the way is to track the state of each transaction using a *state machine*. A state machine is simply a formal definition of what states an object can be in and the transitions that can happen to get it between states. TODO: think of an example.

There's an excellent gem named [aasm][] that makes implementing state machines for ActiveRecord objects very easy. Let's add some more fields to `Sale`:

```bash
$ rails g migration AddFieldsToSale state:string stripe_id:string stripe_token:string card_last4:string card_expiration:string card_type:string email:string error:text product_id:integer
```

Now, add `aasm` to your Gemfile:

```ruby
gem 'aasm'
```

Our state machine will have four possible states:

* *pending* means we just created the record
* *processing* means we're in the middle of processing
* *finished* means we're done talking to Stripe and everything went well
* *errored* means that we're done talking to Stripe and there was an error

We'll also have a few different events for the transaction: `process`, `finish`, and `error`. Let's describe this using `aasm`:

```ruby
class Sale < ActiveRecord::Base
  before_save :populate_guid

  include AASM

  aasm do
    state :pending, initial: true
    state :processing
    state :finished
    state :errored

    event :process, after: :charge_card do
      transitions from: :pending, to: :processing
    end

    event :finish do
      transitions from: :processing, to: :finished
    end

    event :error do
      transitions from: :processing, to: :errored
    end
  end

  def charge_card
    begin
      charge = Stripe::Charge.create(
        amount: self.amount,
        currency: "usd",
        card: self.stripe_token,
        description: self.email,
      )
      self.update_attributes(
        stripe_id:       charge.id,
        card_last4:      charge.card.last4
        card_expiration: Date.new(charge.card.exp_year, Charge.card.exp_month, 1),
        card_type:       charge.card.type
      )
      self.finish!
    rescue Stripe::Error => e
      self.error = e.message
      self.save!
      self.error!
    end
  end

  def populate_guid
    if new_record?
      self.guid = SecureRandom.uuid()
    end
  end
end
```

Inside the `aasm` block, every state we described earlier gets a `state` declaration, and every event gets an `event` declaration. Notice that the `:pending` state is what the record will be created with. Also, notice that the transition from `:pending` to `:processing` has an `:after` callback declared. After `aasm` updates the `state` property and saves the record it will call the `charge_card` method. Among other things, `aasm` will give you predicates to ask the model if it is in a particular state (for example, `finished?`). It will also create scopes for you, so you can find how many finished records there are with `Sale.finished.count`.

We moved the logic to charge the card from the controller into the model. This adheres to the [Fat Model Skinny Controller][fmsc] priciple, where all of the logic lives in the model and the controller just drives it. Let's see what the controller's `create` method looks like now:

```ruby
def create
  product = Product.where(permalink: params[:permalink]).first
  raise ActionController::RoutingError.new("Not found") unless product

  token = params[:stripeToken]
  sale = Sale.create(
    product_id:   product.id,
    amount:       product.price,
    email:        params[:email],
    stripe_token: token
  )
  sale.process!
  if sale.finished?
    redirect_to pickup_url(guid: sale.guid)
  else
    @error = transaction.error
    render :new
  end
end
```

Not that much different, really. We create the Sale object, and then instead of doing the Stripe processing in the controller we call the `process!` method that `aasm` creates. If the sale is finished we'll redirect to the pickup url. If isn't finished we assume it's errored, so we render out the `new` view with the error.

## Audit Trail

Another thing that will be very useful for forensic purposes is an audit trail that tells us every change to a record which acts like a version history. For example, we'll be able to see if transactions are taking a long time to process, if a lot of them start erroring we can see when it happened, etc. The easiest way to implement this is to use a gem named [Paper Trail][paper_trail]. Paper Trail monitors changes on a record and will serialize the state of the object before the change and stuff it into a `versions` table. It has convenient methods for navigating versions, which we'll use to display the history of the record in an admin interface later.

First, add the gem to your Gemfile:

```ruby
gem 'paper_trail', '~> 2'
```

Install the gem, which will generate a migration for you, and run the migration:

```bash
$ rails generate paper_trail:install --with-changes
$ rake db:migrate
```

And now add `has_paper_trail` to the Sale model:

```ruby
class Sale < ActiveRecord::Base
  has_paper_trail

  ... rest of Sale from before
end
```

Now, let's display versions on the Sale show view:

```erb
# in app/views/sales/show.html.erb

<table>
  <thead>
    <tr>
      <th>Timestamp</th>
      <th>Changes</th>
    </tr>
  </thead>
  <tbody>
  <%= @sale.versions.each do |version| %>
    <tr>
      <td><%= version.created_at %></td>
      <td>
        <% version.changeset.sort.each do |key, value| %>
          <b><%= key %></b>: <%= value[0] %> to <%= value[1] %><br>
        <% end %>
      </td>
    </tr>
  <% end %>
  </tbody>
</table>
```

Each change will have a timestamp and a block of changes, one row for each column that changed in that update.

