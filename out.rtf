{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Building Artifacts\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Note: none of this is actually implemented yet.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Desired artifacts:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Website (actually an app where users can login and search and view the guide)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Downloadable HTML\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab PDF\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Mobi\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab ePub\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Implementation:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Use a Rails app that includes the sales engine to actually sell access to the guide\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab App deploy checks out the latest version of the guide, does document conversion on the fly\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Customers get an email with no-login links to download (actually generate) the book as well as a link to create a login to the site for searchable access and updates\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This means that I'm going to have to actually factor everything out into a resuable engine, which means I'm going to need to actually write tests and then I might as well sell the damn thing.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Writing Journal\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 2013-06-01 Sat\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab overall: 1369 135\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 11:00am - 1:30am (2.5)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Set up the initial example app\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Created a repo for the guide itself and copied the TOC into {\field{\*\fldinst{HYPERLINK "/index"}}{\fldrslt{\ul
index
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Wrote draft of {\field{\*\fldinst{HYPERLINK "/initial_app"}}{\fldrslt{\ul
initial app
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Set up a {\field{\*\fldinst{HYPERLINK "http://guide.subspace.bugsplat.info"}}{\fldrslt{\ul
viewer app on subspace
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Imported {\field{\*\fldinst{HYPERLINK "/background_worker"}}{\fldrslt{\ul
background_worker
}}}
 from the blog\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 4:30pm - 6:30pm (2)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Polished {\field{\*\fldinst{HYPERLINK "/background_worker"}}{\fldrslt{\ul
background_worker
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Added a whole section talking about various worker options\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Started writing this journal\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Wrote some rake tasks to count words, sloc, and check for tics\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 2013-06-02 Sun\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab overall: 2071 213 (7%)\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 10:30am - 11:45am (1.25)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Moved bugsplat.info -> petekeen.com, wrote a 400 word blog post about it\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 11:45am - 2:30pm (2.75)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Wrote draft {\field{\*\fldinst{HYPERLINK "/basic_integration"}}{\fldrslt{\ul
basic_integration
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Added a section about deploying to {\field{\*\fldinst{HYPERLINK "/initial_app"}}{\fldrslt{\ul
initial_app
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Added {\f1 download_url} to purchases\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 3:45pm - 6:00pm (2.25)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Implemented the {\field{\*\fldinst{HYPERLINK "/basic_integration"}}{\fldrslt{\ul
basic_integration
}}}
, fixed a bunch of bugs\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 2013-06-03 Mon\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab overall: 2605 213 (9%)\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 6:15am - 7am (0.75)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Wrote about {\field{\*\fldinst{HYPERLINK "/pci"}}{\fldrslt{\ul
PCI compliance
}}}
\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 2013-06-04 Tue\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab overall: 4125 314 (14%)\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 7:00am - 8:00am (1)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Wrote about SSL in {\field{\*\fldinst{HYPERLINK "/pci"}}{\fldrslt{\ul
PCI compliance
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Added a paragraph about how it's not advice about compliance and if you have questions to contact Stripe directly.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 5:30pm - 8:00pm (2.5)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Wrote about paper trail and aasm in {\field{\*\fldinst{HYPERLINK "/state_and_history"}}{\fldrslt{\ul
State and History
}}}
\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 2013-06-08 Sat\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab overall: 5046 457 (17%)\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 10:00am - 11:00am (1)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Implemented {\field{\*\fldinst{HYPERLINK "/state_and_history"}}{\fldrslt{\ul
State and History
}}}
\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 11:00am - 1:30am (2.5)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Wrote and implemented {\field{\*\fldinst{HYPERLINK "/custom_form"}}{\fldrslt{\ul
Custom Payment Forms
}}}
\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 2013-06-09 Sun\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab overall: 5463 484 (18%)\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 10:00am - 12:00am (20\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Started working on {\field{\*\fldinst{HYPERLINK "/callbacks"}}{\fldrslt{\ul
callbacks
}}}
\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Mastering Modern Payments\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Using Stripe with Rails\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Chapters\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Introduction\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab why stripe?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab why rails?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab what we're going to cover\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "/initial_app"}}{\fldrslt{\ul
Initial app description
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab products\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab users/admins\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "/pci"}}{\fldrslt{\ul
PCI Compliance
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "/basic_integration"}}{\fldrslt{\ul
Initial payment integration with checkout.js
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab purchases\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab in-process\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab process transaction\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab associate product with user\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab send user an email\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "/state_and_history"}}{\fldrslt{\ul
Save transaction information with a Transaction record
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab basic record\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab amount charged\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab stripe fee\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab user_id\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab timestamps\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab stripe token\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab card info\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab stripe charge id\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab state machine with aasm\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab rationale\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab implementation\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab save transaction history with paper_trail\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab rationale\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab implementation\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "/custom_form"}}{\fldrslt{\ul
Payment Form with stripe.js
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab iframe\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "/background_worker"}}{\fldrslt{\ul
Use background workers
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab rationale\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab problems they solve\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab different worker systems\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab sucker punch\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab dj\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab resque/sidekiq\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "/callbacks"}}{\fldrslt{\ul
Handling callbacks
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab which callbacks are important\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab for a one-off product site, not very many\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab for subscriptions, more important\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Handling subscriptions\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab creating/managing plans\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab adding users to subscriptions\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab should you automatically cancel if they stop paying? (no)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Email\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab receipts\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab notifications\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab card-about-to-expires\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Admin pages\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab dashboard\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab reports\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab controls\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab refunding transactions\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab cancelling/pausing subscriptions\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Marketplaces with Connect and Payout\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Meta\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "/_hours"}}{\fldrslt{\ul
Journal
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "/_builds"}}{\fldrslt{\ul
Building Artifacts
}}}
\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Processing Payments with Background Workers\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Processing payments correctly is hard. This is one of the biggest lessons I've learned while writing my various {\field{\*\fldinst{HYPERLINK "/projects.html"}}{\fldrslt{\ul
SaaS projects
}}}
. Stripe does everything they can to make it easy, with {\field{\*\fldinst{HYPERLINK "https://stripe.com/docs/tutorials/checkout"}}{\fldrslt{\ul
quick start guides
}}}
 and {\field{\*\fldinst{HYPERLINK "https://stripe.com/docs/api"}}{\fldrslt{\ul
great documentation
}}}
. One thing they really don't cover in the docs is what to do if your connection with their API fails for some reason. Processing payments inside a web request is asking for trouble, and the solution is to run them using a background job.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 The Problem\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Let's take Stripe's example code:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 Stripe.api_key = ENV['STRIPE_API_KEY']\line
\line
# Get the credit card details submitted by the form\line
token = params[:stripeToken]\line
\line
# Create the charge on Stripe's servers - this will charge the user's card\line
begin\line
  charge = Stripe::Charge.create(\line
    :amount => 1000, # amount in cents, again\line
    :currency => "usd",\line
    :card => token,\line
    :description => "payinguser@example.com"\line
  )\line
rescue Stripe::CardError => e\line
  # The card has been declined\line
end\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Pretty straight-forward. Using the {\f1 stripeToken} that {\f1 stripe.js} inserted into your form, create a charge object. If this fails due to a {\f1 CardError}, you can safely assume that the customer's card got declined. Behind the scenes, {\f1 Stripe::Charge} makes an {\f1 https} call to Stripe's API. Typically, this completes almost immediately.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 But what if it doesn't? The internet between your server and Stripe's could be slow or down. DNS resolution could be failing. There's a million reasons why this code could take awhile. Browsers typically have around a one minute timeout and application servers like Unicorn usually will kill the request after 30 seconds. That's a long time to keep the user waiting just to end up at an error page.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 The Solution\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The solution is to put the call to {\f1 Stripe::Charge.create} in a background job. By separating the work that can fail or take a long time from the web request we insulate the user from timeouts and errors while giving our app the ability to retry (if possible) or tell us something failed (if not).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 There's a bunch of different background worker systems available for Rails and Ruby in general, scaling all the way from simple in-process threaded workers with no persistence to external workers persisting jobs to the database or {\field{\*\fldinst{HYPERLINK "http://redis.io"}}{\fldrslt{\ul
Redis
}}}
, then even further to message busses like AMQP, which are overkill for what we need to do.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 In-Process\par}
{\pard \ql \f0 \sa180 \li0 \fi0 One of the best in-process workers that I've come across is called {\field{\*\fldinst{HYPERLINK "https://github.com/brandonhilkert/sucker_punch"}}{\fldrslt{\ul
Sucker Punch
}}}
. Under the hood it uses the actor model to safely use concurrent threads for work processing, but you don't really have to worry about that. It's pretty trivial to use, just include the {\f1 SuckerPunch::Worker} module into your worker class, declare a queue using that class, and chuck jobs into it.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 # in app/workers/banana_worker.rb\line
class BananaWorker\line
  include SuckerPunch::Worker\line
\line
  def perform(event)\line
    puts "I am a banana!"\line
  end\line
end\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 # in config/initializers/queues.rb\line
SuckerPunch.config do\line
  queue name: :banana_queue, worker: BananaWorker, workers: 10\line
end\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 # somewhere in a controller\line
SuckerPunch::Queue[:banana_queue].async.perform("hi")\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The drawback to Sucker Punch, of course, is that if the web process falls over then your jobs evaporate. This will happen, no two ways about it. Errors and deploys will both kill the web process and erase your jobs.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Database Persistence\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The classic, tried-and-true background worker is called {\field{\*\fldinst{HYPERLINK "https://github.com/collectiveidea/delayed_job"}}{\fldrslt{\ul
Delayed Job
}}}
. It's been around since 2008 and is battle tested and production ready. At my day job we use it to process hundreds of thousands of events every day and it's basically fire and forget. It's also easier to use than Sucker Punch. Assuming a class like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 class Banana\line
  def initialize(size)\line
    @size = size\line
  end\line
\line
  def split\line
    puts "I am a banana split, #\{@size\} size!"\line
  end\line
end\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To queue the {\f1 #split} method in a background job, all you have to do is:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 Banana.new('medium').delay.split\par}
{\pard \ql \f0 \sa180 \li0 \fi0 That is, put a call to {\f1 delay} before the call to {\f1 split}. Delayed Job will serialize the object, put it in the database, and then when a worker is ready to process the job it'll do the reverse and finally run the {\f1 split} method.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To work pending jobs, just run\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ bundle exec rake jobs:work\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Delayed Job does have some drawbacks. First, because it stores jobs in the same database as everything else it has to content with everything else. For example, your database serve almost certainly has a limit on the number of connections it can handle, and every worker will require two of them, one for Delayed Job itself and another for any ActiveRecord objects. Second, it can get tricky to backup because you really don't need to be backing up the jobs table. That said, it's relatively simple and straight forward and has the distinct advantage of not making you run any new external services.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Redis\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\field{\*\fldinst{HYPERLINK "http://redis.io"}}{\fldrslt{\ul
Redis
}}}
 bills itself as a "networked data structure server". It's a database server that provides rich data types like lists, queues, sets, and hashes, all while being extremely fast because everything is in-memory all the time. The best Redis-based background worker, in my opinion, is {\field{\*\fldinst{HYPERLINK "http://sidekiq.org"}}{\fldrslt{\ul
Sidekiq
}}}
 written by {\field{\*\fldinst{HYPERLINK "http://www.mikeperham.com"}}{\fldrslt{\ul
Mike Perham
}}}
. It uses the same actor-based concurrency library under the hood as Sucker Punch, but because it stores jobs in Redis it can also provide things like a beautiful management console and fine-grained control over jobs. The setup is essentially identical to Sucker Punch:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 # in app/workers/banana_worker.rb\line
class BananaWorker\line
  include Sidekiq::Worker\line
\line
  def perform(event)\line
    puts "I am a banana!"\line
  end\line
end\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 # somewhere in a controller\line
BananaWorker.perform_async("hi")\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To work jobs, fire up Sidekiq:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ bundle exec sidekiq\par}
{\pard \ql \f0 \sa180 \li0 \fi0 For this example we're going to use Sidekiq. If you'd like to use one of the other job systems described above, or if you already have your own for other things, it should be trivial to change.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 First, let's create a job class:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 class StripeCharger\line
  include Sidekiq::Worker\line
\line
  def perform(event)\line
    ActiveRecord::Base.connection_pool.with_connection do\line
      token =  event[:token]\line
      txn = Transaction.find(event[:transaction_id])\line
\line
      begin\line
        charge = Stripe::Charge.create(\line
          amount: txn.amount,\line
          currency: "usd",\line
          card: token,\line
          description: txn.email\line
        )\line
        txn.state = 'complete'\line
        txn.stripe_id = charge.id\line
        txn.save!\line
      rescue Stripe::Error => e\line
        txn.state = 'failed'\line
        txn.error = e.json_body\line
        txn.save!\line
      end\line
    end\line
  end\line
end\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Again, pretty straightforward. Sidekiq will create an instance of your job class and call {\f1 #perform} on it with a hash of values that you pass in to the queue, which we'll get to in a second. We look up a {\f1 Transaction} record, initiate the charge, and capture any errors that happen along the way.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, in the TransactionsController, replace the transaction processing code with a call to {\f1 perform_async}, like so:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 class TransactionsController < ApplicationController\line
\line
  def create\line
    txn = Transaction.new(\line
      amount: 1000,\line
      email: params[:email],\line
      state: 'pending'\line
    )\line
    if txn.save\line
      StripCharger.perform_async(\line
        transaction_id: txn.id,\line
        token: params[:stripeToken]\line
      )\line
      render json: txn.to_json\line
    else\line
      render json: \{error: txn.error_messages\}, status: 422\line
    end\line
  end\line
  \line
  def show\line
    txn = Transaction.find(params[:id])\line
    raise ActionController::RoutingError.new('not found')\line
      unless txn\line
\line
    render json: txn.to_json\line
  end\line
end\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\f1 create} method creates a new {\f1 Transaction} record, setting it's state to {\f1 pending}. It then queues the transaction to be processed by {\f1 StripeCharger}. The {\f1 show} method simply looks up the transaction and spits back some JSON. On your customer-facing page you'd do something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 function doPoll(id)\{\line
    $.get('/transactions/' + id, function(data) \{\line
        if (data.state === "complete") \{\line
          window.location = '/thankyou';\line
        \} elsif (data.state === "failed") \{\line
          handleFailure(data);\line
        \} else \{\line
          setTimeout(function()\{ doPoll(id); \}, 500);\line
        \}\line
    \});\line
\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Your page will poll {\f1 /transactions/<id>} until the transaction ends in either success or failure. You'd probably want to show a spinner or something to the user while this is happening.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 With this setup, you've insulated yourself from problems in your connection to Stripe, your connection to your customer, and everything in between.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 The Simplest Stripe Integration\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This chapter is going to be a whirlwind integration with Stripe. It's going to be simple and nothing you haven't seen before, but it'll give us something to build on for the next few sections. This is loosely based on Stripe's own {\field{\*\fldinst{HYPERLINK "https://stripe.com/docs/checkout/guides/rails"}}{\fldrslt{\ul
Rails Checkout Guide
}}}
.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Remember that this application is going to be selling digital downloads, so we're going to have two actions:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\b buy} where we create a Sale record and actually charge the customer,\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\b pickup} where the customer can download their product.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Basic Setup\par}
{\pard \ql \f0 \sa180 \li0 \fi0 First, add the Stripe gem to your Gemfile:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 gem 'stripe', git: 'https://github.com/stripe/stripe-ruby'\par}
{\pard \ql \f0 \sa180 \li0 \fi0 And then run {\f1 bundle install}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 We'll also need to set up the Stripe keys:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 # in config/initializers/stripe.rb\line
Rails.configuration.stripe = \{\line
  publishable_key: ENV['STRIPE_PUBLISHABLE_KEY'],\line
  secret_key:      ENV['STRIPE_SECRET_KEY'],\line
\}\line
\line
Stripe.api_key = Rails.configuration.stripe.secret_key\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Note that we're getting the keys from the environment. This is for two reasons: first, because it lets us easily have different keys for testing and for production; second, and more importantly, it means we don't have to hardcode any potentially dangerous security credentials. Putting the keys directly in your code means that anyone with access to your code base can make Stripe transactions with your account.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Controller\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Next, let's create a new controller named {\f1 Transactions} where our Stripe-related logic will live:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 # in app/controllers/transactions_controller.rb\line
\line
class TransactionsController < ApplicationController\line
  skip_before_filter :authenticate_user!, only: [:new, :create]\line
\line
  def new\line
    @product = Product.where(permalink: params[:permalink]).first\line
    raise ActionController::RoutingError.new("Not found") unless @product\line
  end\line
\line
  def show\line
    @sale = Sale.where(guid: params[:guid]).first\line
    raise ActionController::RoutingError.new("Not found") unless @sale\line
    @product = @sale.product\line
  end\line
\line
  def create\line
    product = Product.where(permalink: params[:permalink]).first\line
    raise ActionController::RoutingError.new("Not found") unless product\line
\line
    token = params[:stripeToken]\line
\line
    begin\line
      charge = Stripe::Charge.create(\line
        amount:      product.price,\line
        currency:    "usd",\line
        card:        token,\line
        description: params[:email]\line
      )\line
      sale = Sale.create!(product_id: product.id, email: params[:email])\line
      redirect_to pickup_url(guid: sale.guid)\line
    rescue Stripe::CardError => e\line
      # The card has been declined or some other error has occured\line
      @error = e\line
      render :new\line
    end\line
  end\line
\line
end\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 #new} is just a placeholder for rendering the corresponding view. The real action happens in {\f1 #create} where we look up the product and actually charge the customer. In the last chapter we included a {\f1 permalink} attribute in {\f1 Product} and we use that here to look up the product, mainly because it'll let us generate nicer-looking URLs. If there's an error we display the {\f1 #new} action again. If there's not we redirect to a route named {\f1 pickup}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Routes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The routes for transactions are pretty simple. Add this to {\f1 config/routes.rb}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 match '/buy/:permalink' => 'transactions#new',    via: :get,  as: :buy\line
match '/buy/:permalink' => 'transactions#create', via: :post, as: :buy\line
match '/pickup/:guid'   => 'transactions#show',   via: :get,  as: :pickup\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Why not RESTful URLs?\par}
{\pard \ql \f0 \sa180 \li0 \fi0 RESTful URLs are great if you're building a reusable API, but for this example we're writing a pretty simple website and the customer-facing URLs should look good. If you want to use resources, feel free to adjust the examples.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Views\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Time to set up the views. Put this in {\f1 app/views/transactions/new.html.erb}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 <h1><%= @product.name %></h1>\line
\line
<%= @product.description.html_safe %>\line
\line
<% if @error %>\line
<%= @error %>\line
<% end %>\line
\line
<p>Price: <%= formatted_price(@product.price) %></p>\line
\line
<%= form_tag buy_path(permalink: @product.permalink) do %>\line
  <script src="https://checkout.stripe.com/v2/checkout.js" class="stripe-button"\line
           data-key="<%= Rails.configuration.stripe[:publishable_key] %>"\line
           data-description="<%= @product.name %>"\line
           data-amount="<%= @product.price %>"></script>\line
<% end %>\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Drop the definition for {\f1 formatted_price} into {\f1 app/helpers/application_helper.rb}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 def formatted_price(amount)\line
  sprintf("$%0.2f", amount / 100.0)\line
end\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is a very simple example of a product purchase page with the product's name, description, and a Stripe button using {\f1 checkout.js}. Notice that we just drop the description in as html, so make sure that's locked down. We're rendering this for the {\f1 #create} action, too, so if there's an error we'll display it above the checkout button.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The view for {\f1 #pickup} is even simpler, since it basically just has to display the product's download link. In {\f1 app/views/transactions/pickup.html.erb}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 <h1>Download <%= @product.name %></h1>\line
\line
<p>Thanks for buying "<%= @product.name %>". You can download your purchase by clicking the link below.</p>\line
\line
<p><%= link_to "Download", @product.download_url %></p>\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Deploy\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Add all the new files to git and commit, then run:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ heroku config:add STRIPE_PUBLISHABLE_KEY=pk_your_test_publishable_key STRIPE_SECRET_KEY=sk_your_test_secret_key\line
$ git push heroku master\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You should be able to navigate to {\f1 https://your-app.herokuapp.com/buy/some_permalink} and click the buy button to buy and download a product.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Next\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In this chapter we built (almost) the simplest Stripe integration possible. In the next chapter we're going to cover why and how to save more information about the transaction to our own database.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Handling Webhooks\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Stripe will send your application events that they call webhooks as things happen to payments that you initiate and your users' subscriptions. The full list of event types can be found in Stripe's API documentation, but here's a brief list:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab when a charge succeeds or fails\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab when a subscription is due to be renewed\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab when something about a customer changes\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab when a customer disputes a charge\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Some of these are more important than others. For example, if you're selling one-off products you probably don't care about the events about charge successes and failures because you're initiating the charge and will know immediately how it went. Those events are more useful for subscription sites where Stripe is handling the periodic billing for you. On the other hand, you always want to know about charge disputes. Too many of those and Stripe may drop your account.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Webhook handling is going to be unique to every application. For the example app we're just going to handle disputes for now. We'll add more when we get to the chapter about subscriptions.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Validating Events\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Stripe unfortunately does not sign their events. If they did we could verify that they sent them cryptographically, but because they don't the best thing to do is to take the ID from the POSTed event data and ask Stripe about it directly. Stripe also recommends that we store events and reject IDs that we've seen already to protect against replay attacks. To knock both of these requirements out at the same time, lets make a new model called Event:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ rails g model Event \\\line
    stripe_id:string \\\line
    type:string\par}
{\pard \ql \f0 \sa180 \li0 \fi0 We only need to store the {\f1 stripe_id} because we'll be looking up the event using the API every time. Storing the type could be useful later on for reporting purposes.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The model should look like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 class Event < ActiveRecord::Base\line
  validates_uniqueness_of :stripe_id\line
\line
  def stripe_event\line
    Stripe::Event.retrieve(stripe_id)\line
  end\line
end\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Controller\par}
{\pard \ql \f0 \sa180 \li0 \fi0 We'll need a new controller to handle callbacks:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 # in app/controllers/events.rb\line
\line
class EventsController < ApplicationController\line
  skip_before_filter :authenticate_user!\line
  before_filter :parse_and_validate_event\line
\line
  def create\line
    render :nothing => true, :status => 200\line
  end\line
\line
  private\line
  def parse_and_validate_event\line
    event = JSON.parse(request.body.read)\line
    @event = Event.new(id: event['id'], type: event['type'])\line
    unless event.save\line
      render :nothing => true, :status => 400\line
      return\line
    end\line
    @stripe_event = @event.stripe_event\line
  end\line
end\par}
{\pard \ql \f0 \sa180 \li0 \fi0 From the top, we skip Devise's {\f1 authenticate_user!} before filter because Stripe is obviously not going to have a user for our application. Then, we make our own {\f1 before_filter} that actually parses out the event and does the work of preventing replay attacks. If the event doesn't validate for some reason we return 400 and move on. If, on the other hand, it saves correctly we ask Stripe for a fresh copy of the event and then deal with it. All {\f1 #create} has to do is return 200 to tell Stripe that we successfully dealt with the event.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 But we haven't actually done anything yet. [bootstrap]: http://twitter.github.io/bootstrap [tutorial]: https://stripe.com/docs/tutorials/forms\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Custom Payment Forms\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Until now we've been using Stripe's excellent {\f1 checkout.js} that provides a popup iframe to collect credit card information, post it to Stripe and turn it into a {\f1 stripeToken} and then finally post our form. There's something conspicuously absent from all of this, however. Remember how Sale has an email attribute? We're not populating that right now because {\f1 checkout.js} doesn't easily let us add our own fields. For that we'll need to create our own form. Stripe still makes this easy, though, with {\f1 stripe.js}. The first half of this chapter is adapted from Stripe's [custom form tutorial][tutorial].\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Here's the form we'll be using:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 <%= form_tag buy_path(permalink: @product.permalink), :class => 'form-horizontal', :id => 'payment-form' do %>\line
  <span class="payment-errors"></span>\line
  <div class="control-group">\line
    <label class="control-label" for="email">Email</label>\line
    <div class="controls">\line
      <input type="email" name="email" id="email" placeholder="Email"/>\line
    </div>\line
  </div>\line
  <div class="control-group">\line
    <label class="control-label" for="number">Card Number</label>\line
    <div class="controls">\line
      <input type="text" size="20" data-stripe="number" id="number" placeholder="**** **** **** ****"/>\line
    </div>\line
  </div>\line
\line
  <div class="control-group">\line
    <label class="control-label" for="cvc">CVC</label>\line
    <div class="controls">\line
      <input type="text" size="3" data-stripe="cvc" id="cvc" placeholder="***"/>\line
    </label>\line
  </div>\line
\line
  <div class="form-row">\line
    <label class="control-label">Expiration (MM/YYYY)</label>\line
    <div class="controls">\line
      <input type="text" size="2" data-stripe="exp-month" placeholder="MM"/>\line
      <span> / </span>\line
      <input type="text" size="4" data-stripe="exp-year" placeholder="YYYY"/>\line
    </div>\line
  </div>\line
\line
  <div class="form-row">\line
    <div class="controls">\line
      <button type="submit" class="btn btn-primary">Pay</button>\line
    </div>\line
  </div>\line
<% end %>\par}
{\pard \ql \f0 \sa180 \li0 \fi0 There's a few interesting things going on here. First, notice the almost-excessive amount of markup. I'm using [Twitter Bootstrap][bootstrap] form markup for this, which gives nice looking styling by default.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Second, take a look at the inputs. Only one of them, {\f1 email}, actually has a {\f1 name} attribute. The rest have {\f1 data-stripe} attributes. Browsers will only send inputs that have a {\f1 name} to the server, the rest get dropped on the floor. In this case, the inputs with {\f1 data-stripe} attributes will get picked up by {\f1 stripe.js} automatically and fed to Stripe's servers to be turned into a token.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To do that we need to actually send the form to Stripe. First include {\f1 stripe.js} in the page. Stripe recommends you do this in the header for compatibility with older browsers, but we're just going to stick it in the body for now. Put this at the bottom of the page:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 <script type="text/javascript" src="https://js.stripe.com/v2/"></script>\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Next, Stripe needs our publishable key. Remember that we have that in the Rails config due to the initializer we {\field{\*\fldinst{HYPERLINK "/initial_app"}}{\fldrslt{\ul
set up before
}}}
. To set it, call {\f1 Stripe.setPublishableKey()} like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 <script type="text/javascript">\line
$(function(\{\line
  Stripe.setPublishableKey('<%= Rails.configuration.stripe[:publishable_key] %>');\line
\});\line
</script>\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To intercept the form submission process, tack on a {\f1 submit} handler using jQuery:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $('#payment-form').submit(function(event) \{\line
  var form = $(this);\line
  form.find('button').prop('disabled', true);\line
  Stripe.createToken(form, stripeResponseHandler);\line
  return false;\line
\});\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When the customer clicks the "Pay" button we disable the button so they can't click it again, then call {\f1 Stripe.createToken}, passing in the form and a callback function. Stripe's javascript will submit all of the inputs with a {\f1 data-stripe} attribute to their server, create a token, and call the callback function with a status and response. The implmentation of {\f1 stripeResponseHandler} is pretty straightforward:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 function stripeResponseHandler(status, response) \{\line
  var form = $('#payment-form');\line
  if (response.error) \{\line
    form.find('.payment-errors').text(response.error.message);\line
    form.find('button').prop('disabled', false);\line
  \} else \{\line
    var token = response.id;\line
    form.append($('<input type="hidden" name="stripeToken">').val(token));\line
    form.get(0).submit();\line
  \}\line
\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If the response has an error, display the error and re-enable the "Pay" button. Otherwise, append a hidden input to the form and resubmit using the DOM method instead of the jQuery method so we don't get stuck in an infinite loop.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Embedding the Form\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Custom forms are all well and good, but wouldn't it be cool if we could embed it in another page just like Stripe's Checkout? Let's give it a shot. Create a file {\f1 public/example.html} and put this in it:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 <html>\line
  <head>\line
    <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" rel="stylesheet">\line
  </head>\line
  <body>\line
    <h1>Example Iframe</h1>\line
    <button class="btn btn-primary" id="openBtn">Buy</button>\line
    <div id="paymentModal" class="modal hide fade" role="dialog">\line
      <div class="modal-body">\line
        <iframe src="" style="zoom:0.6" width="99.6%" height="550" frameborder="0"></iframe>\line
      </div>\line
    </div>\line
    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.2/jquery.min.js"></script>\line
    <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>\line
    <script type="text/javascript">\line
      var frameSrc = "/buy/design-for-failure"; // You'll want to customize this.\line
      $("#openBtn").click(function() \{\line
        $("#paymentModal").on("show", function() \{\line
          $('iframe').attr('src', frameSrc);\line
        \});\line
        $("#paymentModal").modal(\{show: true\});\line
      \});\line
    </script>\line
  </body>\line
</html>\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This page loads jQuery and Twitter Bootstrap from public CDNs and then uses them to create a Bootstrap Modal containing an {\f1 iframe}. Initially this iframe's {\f1 src} attribute is set to nothing. This is to prevent the iframe from loading on page load which could cause a lot of unnecessary traffic on the server running the sales application. When the customer clicks the button we set up the {\f1 src} attribute of the iframe and then show the modal.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is pretty cool but also problematic. The iframe just loads the normal {\f1 /buy} action which contains the whole product description. Second, and more importantly, after the customer buys the thing they expect to be able to click on the download link and save the product, but that won't happen because we haven't set the {\f1 X-Frame-Options} header to allow the iframe to do anything. Let's fix the first problem. Move the form into a new partial named {\f1 _form.html.erb} and then call it like this in {\f1 transactions/new.html.erb}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 <%= render :partial => 'form' %>\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Then, create a new action named {\f1 iframe}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 # in config/routes.rb\line
\line
match '/iframe/:permalink' => 'transactions#iframe', via: :get, as: :buy_iframe\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 # in app/controllers/transactions_controller.rb\line
\line
def iframe\line
  @product = Product.where(permalink: params[:permalink]).first\line
  raise ActionController::RoutingError.new("Not found") unless @product\line
end\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In {\f1 app/views/transactions/iframe.html.rb}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 <h1><%= @product.name %></h1>\line
\line
<p>Price: <%= formatted_price(@product.price) %></p>\line
\line
<%= render :partial => 'form' %>\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, change {\f1 frameSrc} to point at {\f1 /iframe/design-for-failure} and reload the page.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 We can fix the other problem, with the {\f1 X-Frame-Options} header, simply by changing the language to say "Make sure to right-click and select Save As" indead of just telling the customer to click the link. In a later chapter I'll talk about emailing and we'll be changing this some more.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Initial Application\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In this chapter we're going to create a simple rails application so we have something to work with for later chapters. All of the rest of the examples in the guide will be based on this app. You can either follow along with the instructions or use the app in the {\f1 sales} directory in the example code.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A note on versions. The example app will be using Rails 3.2.13 and PostgreSQL 9.2.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Our app will sell downloadable products. Users will be able to create products and customers will be able to buy them, and we'll keep track of sales so we can do reporting later. Customers will be able to come back and download their purchases multiple times. We'll three models:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\b Product}, representing a product that we're going to be selling.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\b User}, for logging in and managing products\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\b Sale}, to represent each individual customer purchase\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Boilerplate\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Let's create an initial application:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ rails new sales --database postgresql --test-framework=rspec\line
$ cd sales\line
$ createuser -s sales\line
$ rake db:setup\line
$ rake db:migrate\line
$ rake test\par}
{\pard \ql \f0 \sa180 \li0 \fi0 I'm going to use {\field{\*\fldinst{HYPERLINK "http://www.postgresql.org"}}{\fldrslt{\ul
PostgreSQL
}}}
 for the example app because that's what I know best, it's what {\field{\*\fldinst{HYPERLINK "https://www.heroku.com"}}{\fldrslt{\ul
Heroku
}}}
 provides for free, and it's what I suggest to everyone who asks. If you want to use a different database, feel free to substitute. Any {\f1 ActiveRecord}-compatible database should be sufficient.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Authentication\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Eventually we're going to want to be able to authenticate users and admins. The example is going to use a gem named {\field{\*\fldinst{HYPERLINK "https://github.com/plataformatec/devise"}}{\fldrslt{\ul
Devise
}}}
 which handles everything user-related out of the box. Add it to your {\f1 Gemfile}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 gem 'devise', '~> 2.2.4'\par}
{\pard \ql \f0 \sa180 \li0 \fi0 then run bundler and set up Devise:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ bundle install\line
$ rails generate devise:install\par}
{\pard \ql \f0 \sa180 \li0 \fi0 At this point you have to do some manual configuration. Add this to {\f1 config/environments/development.rb}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 config.action_mailer.default_url_options = \{ :host => 'localhost:3000' \}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This to {\f1 config/routes.rb}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 root :to => 'products#index'\par}
{\pard \ql \f0 \sa180 \li0 \fi0 and this in {\f1 app/views/layouts/application.html.erb} right after the {\f1 body} tag:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 <p class="notice"><%= notice %></p>\line
<p class="alert"><%= alert %></p>\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Also, you'll want to delete {\f1 public/index.html} because it gets in Devise's way.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, let's create a User model for devise to work with:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ rails generate devise User\line
$ rake db:migrate\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Open up {\f1 app/controllers/application_controller.rb} and add this line, which will secure everything by default:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 before_filter :authenticate_user!\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You'll need to a user so you can actually log in to the site. Fire up {\f1 rails console} and type:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 User.create!(email: 'you@example.com', password: 'password', password_confirmation: 'password')\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Models\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Our sales site needs something to sell, so let's create a product model:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ rails g scaffold Product name:string permalink:string description:text price:integer user_id:integer download_url:text\line
$ rake db:migrate\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 name} and {\f1 description} will actually get displayed to the customer, {\f1 permalink} and {\f1 download_url} will be used later. Open up {\f1 app/models/product.rb} and change it too look like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 class Product < ActiveRecord::Base\line
  attr_accessible :description, :name, :permalink, :price, :user_id, :download_url\line
\line
  belongs_to :user\line
end\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The sales site needs a way to track, you know, sales. Let's make a Sale model too.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ rails g scaffold Sale email:string guid:string product_id:integer\line
$ rake db:migrate\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Open up {\f1 app/models/sale.rb} and make it look like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 class Sale < ActiveRecord::Base\line
  attr_accessible :email, :product_id\line
\line
  belongs_to :product\line
\line
  before_save :populate_guid\line
\line
  def populate_guid\line
    if new_record?\line
      self.guid = SecureRandom.uuid()\line
    end\line
  end\line
end\par}
{\pard \ql \f0 \sa180 \li0 \fi0 We're using a GUID here so that when we eventually allow the user to look at their transaction they won't see the {\f1 id}, which means they won't be able to guess the next ID in the sequence and potentially see someone else's transaction.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Deploying\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\field{\*\fldinst{HYPERLINK "https://www.heroku.com"}}{\fldrslt{\ul
Heroku
}}}
 is bar-none the fastest way to get a Rails app deployed into a production environment, so that's what we're going to use throughout the guide. If you already have a deployment system for your application by all means use that. First, download and install the {\field{\*\fldinst{HYPERLINK "https://toolbelt.heroku.com"}}{\fldrslt{\ul
Heroku Toolbelt
}}}
 for your platform. Make sure you {\f1 heroku login} to set your credentials.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 We have to add one more config option. Because of how Heroku handles databases, our app does not have access to the database while compiling assets. Conveniently Rails has an option to turn off connecting to the database at that time. Set it in {\f1 config/application.rb}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 config.assets.initialize_on_precompile = false\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Next, create an appliation and deploy the example code to it:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ heroku create\line
$ git init .\line
$ git add .\line
$ git commit -m 'Initial commit'\line
$ git push heroku master\line
$ heroku run rake db:migrate\line
$ heroku run console # create a new user like we did before in the local console\line
$ heroku restart web # restart the web dyno to pick up the database changes\line
$ heroku open\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You should see a login prompt from Devise. Go ahead and login and create a few products. We'll get to buying and downloading in the next chapter.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Next\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now we have a very simple application which will be enough to get going. We have things to sell and a way to track sales, as well as authentication so not just anybody can come muck with our stuff. Next, we'll run through the simplest Stripe integration and actually sell some stuff.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 PCI Compliance\par}
{\pard \ql \f0 \sa180 \li0 \fi0 One of the biggest reasons to choose Stripe over other ways of processing credit cards is that they minimize your exposure to {\i PCI compliance}. PCI stands for "{\field{\*\fldinst{HYPERLINK "https://www.pcisecuritystandards.org"}}{\fldrslt{\ul
Payment Card Industry
}}}
", if you were wondering.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Note: I'm not an expert in PCI compliance and this chapter shouldn't be interpreted as legal advice about it. Rather, this is background information and advice on how to implement Stripe's guidelines. If you have questions, please ask Stripe.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Back in the early 2000s the credit card industry got together and decided on a whole bunch of interrelated standards for how to secure a payment system such that personally identifiable information, especially credit card numbers, is unlikely to be leaked to the outside world. For example, before the era of PCI compliance it was common for your unencrypted credit card number to be tacked onto your user record in an application database. Also, it was typical for sites to use plain HTTP for payment forms instead of HTTPS.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, though, both of those practices along with a host of others would get your merchant account cancelled. Being PCI compliant means that you adhere to all of the practices that apply to the way you process credit cards. Stripe is certified Service Provider Level 1, which means they have to have store credit card information encrypted in separate machines, possibly in separate data centers, than all of the rest of their infrastructure. It also means that nobody internal to Stripe can access unencrypted credit card numbers. Their software makes charges based on your API calls by sending information to an exclusive set of providers, entirely hidden from employees.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Stripe and PCI\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The real revolutionary part of how Stripe works is in how they {\field{\*\fldinst{HYPERLINK "https://stripe.com/help/security"}}{\fldrslt{\ul
reduce your compliance scope
}}}
 as a merchant. Before Stripe, a typical online merchant would have a normal HTML form on their website where customers would put in their credit card information. This form would post to the merchant's server, where they would take the credit card info and pass it along to their {\i gateway service}, which would then talk to all of the various banks and things and then eventually deposit the money into their {\i merchant account}. This means, among other things, that each merchant would have to become PCI certified, even if they weren't storing the credit card info anywhere in their system. Theoretically, an attacker could stick some code into a merchant's payment processing system and divert credit card numbers. Or, if the merchant's site wasn't using HTTPS they could perform a man-in-the-middle attack and capture credit card info that way.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Stripe, with {\f1 stripe.js}, makes all of this irrelevant. When you create a form using {\f1 stripe.js} or {\f1 checkout.js} loaded from Stripe's servers, none of the customer's credit card info is sent through your servers. The javascript that gets injected into your form instead sends that info to Stripe's servers over HTTPS, where they turn it into a single-use {\i token}. Your server can then use that token to refer to a customer's credit card without having seen it at all.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The only thing you as a merchant have to do to be PCI compliant in this situation is to make sure you're serving up your payment-related pages over HTTPS. As long as you're loading {\f1 stripe.js} from Stripe via HTTPS into a secure webpage which POSTs to a secure endpoint, and you make sure not to put {\f1 name}s on any of the credit-card-related fields in the form (only fields with {\f1 name}s get POSTed), you don't have to worry about PCI compliance at all.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Implementing HTTPS with Rails\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Rails after v3.1 makes forcing visitors to HTTPS incredibly easy. In {\f1 config/environments/production.rb}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 config.force_ssl = true\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This will redirect all non-https requests to your website to the secure endpoint automatically on production. For this example it's all we need to do because Heroku provides what's called a "wildcard ssl certificate" for all apps accessed at {\f1 herokuapp.com}. However, if you're using your own URL you'll need to get your own certificate (generally around $10 per year) and install it with Heroku, which will run $20 per month. These costs vary, of course, if you're using a different hosting provider. Most Amazon-based cloud providers will charge $20 because that's how much an Elastic Load Balancer costs.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Buying a Certificate\par}
{\pard \ql \f0 \sa180 \li0 \fi0 There are many different places where you can buy a certificate. I've had good luck buying them through my registrar [Namecheap.com][namecheap]. The steps are:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Generate a private key\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Using your private key, generate a Certificate Signing Request\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Send the CSR to Namecheap\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Receive your shiny new certificate\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Remove the passphrase from your certificate so that the webserver can use it.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 First make sure you have {\f1 openssl} installed on your machine. It comes installed by default on Mac OS X but on Linux you may have to install it from your package manager.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Generate a Private Key\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ openssl genrsa -out example.com.key 2048\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This generates a 2048 bit {\field{\*\fldinst{HYPERLINK "http://en.wikipedia.org/wiki/RSA_(algorithm)"}}{\fldrslt{\ul
RSA key
}}}
 and stores it in {\f1 example.com.key}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Generate a Certificate Signing Request\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ openssl req -new -key example.com.key -out example.com.csr\par}
{\pard \ql \f0 \sa180 \li0 \fi0 OpenSSL will ask you a bunch of questions now. Fill them in like the prompts, but when you get to the {\f1 Common Name} question, use the exact name of web server. Note that this really does have to be an exact match, so if you want to secure, say, {\f1 www.example.com}. that's what you should use. Putting just {\f1 example.com} won't work. For a wildcard certificate you'd put {\f1 *.example.com}, which would let you secure {\f1 foo.example.com} and {\f1 bar.example.com}, but those cost quite a bit more than individual certificates.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Also, make sure to leave extra attributes including the challenge password blank.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Validate your new CSR\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ openssl req -noout -text -in example.com.csr\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This will print out a bunch of information about your certificate. You can ignore almost all of it, but pay attention to the line {\f1 CN=example.com}. This should match what you put in for your server name in the {\f1 Common Name} field.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Buy the actual certificate\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Head on over to {\field{\*\fldinst{HYPERLINK "http://www.namecheap.com/ssl-certificates.aspx"}}{\fldrslt{\ul
Namecheap's SSL page
}}}
. Here you're presented with a bunch of different options presented in what they feel is least-secure to most-secure list. I generally buy the cheapest option because they're all pretty much the same in the $10 range. If you want, you can get EV1 certification which will give you the green bar in Safari and Firefox. You'll have to do some more paperwork to get it, though. For now, let's just get the cheapest Comodo certificate.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Go through checkout and pay and you'll get sent to a page where you can pick your server type and paste your CSR. For Heroku you should choose the "Other" option in the server dropdown. Open your CSR up and paste the entire contents into the text box, then hit Next.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Namecheap will give you a list of email addresses to choose from. This is where it's going to send the verification email that contains a link you have to click to proceed through the process. If you don't already have one of these email aliases set up, you should do so now before picking one and clicking Next.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You'll now be prompted to enter your administrative contact info, which it helpfully copied from your domain registration if you registered through Namecheap. Fill this stuff out, then hit Next.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You'll get taken to a web page with a handy dandy flow chart, and within a few mintues you'll get an email. Click the link in the email, copy and paste the verification code, and hit the "Next" button. You'll get another email, this one with your new certificate attached.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Installing the certificate at Heroku\par}
{\pard \ql \f0 \sa180 \li0 \fi0 At this point, you'll need to attach the SSL certificate to your application. With Heroku, {\field{\*\fldinst{HYPERLINK "https://devcenter.heroku.com/articles/ssl-endpoint"}}{\fldrslt{\ul
this is easy
}}}
.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ heroku addons:add ssl:endpoint\line
$ heroku certs:add www.example.com.crt bundle.pem example.com.key\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To see if the certificate installed properly:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ heroku certs\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now just configure {\f1 www.example.com} as a CNAME pointing at the {\f1 herokussl.com} endpoint printed from {\f1 heroku certs} and test it out:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ curl -kvI https://www.example.com\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This should print out a bunch of stuff about SSL and the headers from your application.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 State and History\par}
{\pard \ql \f0 \sa180 \li0 \fi0 So far in our little example app we can buy and sell downloadable products using Stripe. We're not keeping much information in our own database, though. We can't easily see how much we've earned, we can't see how big Stripe's cut has been. Ideally our application's database would keep track of this. The mantra with financial transactions should always be "trust and verify". To that end we should be tracking sales through each stage of the process, from the point the customer clicks the buy button all the way through to a possible refund. We should know, at any given moment, what state a transaction is in and it's entire history.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 State Machines\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The first step of tracking is to turn each transaction into a {\i state machine}. A state machine is simply a formal definition of what states an object can be in and the transitions that can happen to get it between states. At any given moment an object can only be in a single state. For example, consider a subway turnstile. Normally it's locked. When you put a coin in or swipe your card, it unlocks. Then when you pass through or a timer expires, it locks itself again. We could model that like this, using a gem called {\field{\*\fldinst{HYPERLINK "https://github.com/aasm/aasm"}}{\fldrslt{\ul
AASM
}}}
:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 class Turnstile\line
\line
  include AASM\line
\line
  aasm do\line
    state :locked, initial: true\line
    state :unlocked\line
\line
    event :pay\line
      transitions from: :locked, to: :unlocked\line
    end\line
\line
    event :use\line
      transitions from: :unlocked, to: locked\line
    end\line
  end\line
end\par}
{\pard \ql \f0 \sa180 \li0 \fi0 AASM is the successor to a previous gem named {\f1 acts_as_state_machine} which was hard-coded to ActiveRecord objects and had a few problems. AASM fixes those problems and lets you describe state machines inside any class, not just ActiveRecord. As you can see, it implements a simple DSL for states and events. AASM will create a few methods on instances of Turnstile, things like {\f1 pay!} and {\f1 use!} to trigger the corresponding events and {\f1 locked?} and {\f1 unlocked?} to ask about the state.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 AASM can also be used with ActiveRecord, just like it's predecessor. Let's begin by adding some more fields to {\f1 Sale}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ rails g migration AddFieldsToSale \\\line
    state:string \\\line
    stripe_id:string \\\line
    stripe_token:string \\\line
    card_last4:string \\\line
    card_expiration:string \\\line
    card_type:string \\\line
    error:text \\\line
    fee_amount:integer\line
$ rake db:migrate\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, add {\f1 aasm} to your Gemfile and run {\f1 bundle install}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 gem 'aasm'\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The Sale state machine will have four possible states:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\i pending} means we just created the record\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\i processing} means we're in the middle of processing\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\i finished} means we're done talking to Stripe and everything went well\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\i errored} means that we're done talking to Stripe and there was an error\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It'll also have a few different events for the transaction: {\f1 process}, {\f1 finish}, and {\f1 fail}. Let's describe this using {\f1 aasm}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 class Sale < ActiveRecord::Base\line
  attr_accessible\line
    :email,\line
    :guid,\line
    :product_id,\line
    :state,\line
    :stripe_id,\line
    :stripe_token,\line
    :card_last4,\line
    :card_expiration,\line
    :error,\line
    :fee_amount\line
\line
before_save :populate_guid\line
\line
  include AASM\line
\line
  aasm column: 'state', skip_validation_on_save: true do\line
    state :pending, initial: true\line
    state :processing\line
    state :finished\line
    state :errored\line
\line
    event :process, after: :charge_card do\line
      transitions from: :pending, to: :processing\line
    end\line
\line
    event :finish do\line
      transitions from: :processing, to: :finished\line
    end\line
\line
    event :fail do\line
      transitions from: :processing, to: :errored\line
    end\line
  end\line
\line
  def charge_card\line
    begin\line
      save!\line
      charge = Stripe::Charge.create(\line
        amount: self.amount,\line
        currency: "usd",\line
        card: self.stripe_token,\line
        description: self.email,\line
      )\line
      self.update_attributes(\line
        stripe_id:       charge.id,\line
        card_last4:      charge.card.last4\line
        card_expiration: Date.new(charge.card.exp_year, Charge.card.exp_month, 1),\line
        card_type:       charge.card.type,\line
        fee_amount:      charge.fee\line
      )\line
      self.finish!\line
    rescue Stripe::Error => e\line
      self.update_attributes(error: e.message)\line
      self.fail!\line
    end\line
  end\line
\line
  def populate_guid\line
    if new_record?\line
      self.guid = SecureRandom.uuid()\line
    end\line
  end\line
end\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Inside the {\f1 aasm} block, every state we described earlier gets a {\f1 state} declaration, and every event gets an {\f1 event} declaration. Notice that the {\f1 :pending} state is what the record will be created with. Also, notice that the transition from {\f1 :pending} to {\f1 :processing} has an {\f1 :after} callback declared. After AASM updates the {\f1 state} property and saves the record it will call the {\f1 charge_card} method. AASM will automatically create scopes, so for example you can find how many finished records there are with {\f1 Sale.finished.count}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Notice that the stuff about charging the card moved into the model. This adheres to the {\field{\*\fldinst{HYPERLINK "http://weblog.jamisbuck.org/2006/10/18/skinny-controller-fat-model"}}{\fldrslt{\ul
Fat Model Skinny Controller
}}}
 principle, where all of the logic lives in the model and the controller just drives it. Here's how {\f1 TransactionsController#create} method looks now:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 def create\line
  @product = Product.where(permalink: params[:permalink]).first\line
  raise ActionController::RoutingError.new("Not found") unless @product\line
\line
  token = params[:stripeToken]\line
  sale = Sale.create(\line
    product_id:   @product.id,\line
    amount:       @product.price,\line
    email:        params[:email],\line
    stripe_token: token\line
  )\line
  sale.process!\line
  if sale.finished?\line
    redirect_to pickup_url(guid: sale.guid)\line
  else\line
    flash[:alert] = sale.error\line
    render :new\line
  end\line
end\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Not that much different, really. We create the Sale object, and then instead of doing the Stripe processing in the controller we call the {\f1 process!} method that {\f1 aasm} creates. If the sale is finished we'll redirect to the pickup url. If isn't finished we assume it's errored, so we render out the {\f1 new} view with the error.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It would be nice to see all of this information we're saving now. Let's change the {\f1 Sales#show} template to dump out all of the fields:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 <p id="notice"><%= notice %></p>\line
<table>\line
  <tr>\line
    <th>Key</th>\line
    <th>Value</th>\line
  </tr>\line
  <% @sale.attributes.sort.each do |key, value| %>\line
  <tr>\line
    <td><%= key %></td>\line
    <td><%= value %></td>\line
  </tr>>\line
  <% end %>\line
</table>\line
\line
<%= link_to 'Back', sales_path %>\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Audit Trail\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Another thing that will be very useful is an audit trail that tells us every change to a record. Every time AASM updates the {\f1 state} field, every change that happens during the charging process, every change to the object at all. There are a few different schools of thought on how to implement this. The classical way would be to use database triggers to write copies of the database rows into an audit table. This has the advantage of working whether you use the ActiveRecord interface or straight SQL queries, but it's really hard to implement properly. The easiest way to implement audit trails that I've found is to use a gem named {\field{\*\fldinst{HYPERLINK "https://github.com/airblade/paper_trail"}}{\fldrslt{\ul
Paper Trail
}}}
. Paper Trail monitors changes on a record using ActiveRecord's lifecycle events and will serialize the state of the object before the change and stuff it into a {\f1 versions} table. It has convenient methods for navigating versions, which we'll use to display the history of the record in an admin interface later.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 First, add the gem to your Gemfile:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 gem 'paper_trail', '~> 2'\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Install the gem, which will generate a migration for you, and run the migration:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ rails generate paper_trail:install --with-changes\line
$ rake db:migrate\par}
{\pard \ql \f0 \sa180 \li0 \fi0 And now add {\f1 has_paper_trail} to the Sale model:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 class Sale < ActiveRecord::Base\line
  has_paper_trail\line
\line
  ... rest of Sale from before\line
end\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 has_paper_trail} takes a bunch of options for things like specifiying which lifecycle events to monitor, which fields to include and which to ignore, etc. which are all described in it's documentation. The defaults should usually be fine.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Here's some simple code for the {\f1 SalesController#show} action to display the history of the sale:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 # in app/views/sales/show.html.erb\line
\line
<table>\line
  <thead>\line
    <tr>\line
      <th>Timestamp</th>\line
      <th>Event</th>\line
      <th>Changes</th>\line
    </tr>\line
  </thead>\line
  <tbody>\line
  <%= @sale.versions.each do |version| %>\line
    <tr>\line
      <td><%= version.created_at %></td>\line
      <td><%= version.event %></td>\line
      <td>\line
        <% version.changeset.sort.each do |key, value| %>\line
          <b><%= key %></b>: <%= value[0] %> to <%= value[1] %><br>\line
        <% end %>\line
      </td>\line
    </tr>\line
  <% end %>\line
  </tbody>\line
</table>\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Each change will have a timestamp, the event, and a block of changes, one row for each column that changed in that update. For a typical completed sale there will be three rows, "pending", "processing", and "completed" with all of the information from Stripe.\par}

